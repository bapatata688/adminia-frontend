{"ast":null,"code":"/**\n * Solicitar reset de contraseña\n */\nexport const forgotPassword = async email => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.FORGOT_PASSWORD, {\n      email\n    });\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Resetear contraseña con token\n */\nexport const resetPassword = async (token, newPassword) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.RESET_PASSWORD, {\n      token,\n      newPassword\n    });\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Verificar si el usuario está autenticado\n */\nexport const isAuthenticated = () => {\n  return TokenManager.hasValidSession();\n};\n\n/**\n * Obtener información del usuario desde localStorage\n */\nexport const getUserFromStorage = () => {\n  return TokenManager.getUser();\n};\n\n/**\n * ============================================\n * SERVICIO DE AUTENTICACIÓN - Frontend\n * ============================================\n * Archivo: services/auth.js\n * Propósito: Manejo de autenticación y tokens en el cliente\n * \n * Funciones principales:\n * - login: Iniciar sesión\n * - register: Registrar nuevo usuario\n * - logout: Cerrar sesión\n * - refreshToken, rememberToken, user\n */\n\nimport axios from 'axios';\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\nconst AUTH_ENDPOINTS = {\n  LOGIN: `${API_URL}/auth/login`,\n  REGISTER: `${API_URL}/auth/register`,\n  LOGOUT: `${API_URL}/auth/logout`,\n  REFRESH: `${API_URL}/auth/refresh`,\n  ME: `${API_URL}/auth/me`,\n  UPDATE_PROFILE: `${API_URL}/auth/update-profile`,\n  FORGOT_PASSWORD: `${API_URL}/auth/forgot-password`,\n  RESET_PASSWORD: `${API_URL}/auth/reset-password`,\n  LOGIN_WITH_REMEMBER: `${API_URL}/auth/login-with-remember`\n};\n\n/**\n * Gestión de tokens en localStorage\n */\nexport const TokenManager = {\n  getAccessToken: () => localStorage.getItem('accessToken'),\n  setAccessToken: token => {\n    if (token) {\n      localStorage.setItem('accessToken', token);\n    } else {\n      localStorage.removeItem('accessToken');\n    }\n  },\n  getRefreshToken: () => localStorage.getItem('refreshToken'),\n  setRefreshToken: token => {\n    if (token) {\n      localStorage.setItem('refreshToken', token);\n    } else {\n      localStorage.removeItem('refreshToken');\n    }\n  },\n  getRememberToken: () => localStorage.getItem('rememberToken'),\n  setRememberToken: token => {\n    if (token) {\n      localStorage.setItem('rememberToken', token);\n    } else {\n      localStorage.removeItem('rememberToken');\n    }\n  },\n  getUser: () => {\n    const userStr = localStorage.getItem('user');\n    return userStr ? JSON.parse(userStr) : null;\n  },\n  setUser: user => {\n    if (user) {\n      localStorage.setItem('user', JSON.stringify(user));\n    } else {\n      localStorage.removeItem('user');\n    }\n  },\n  clearAll: () => {\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('rememberToken');\n    localStorage.removeItem('user');\n  },\n  hasValidSession: () => {\n    return !!TokenManager.getAccessToken() || !!TokenManager.getRememberToken();\n  }\n};\n\n/**\n * Configurar interceptor de axios para incluir token automáticamente\n */\nexport const setupAxiosInterceptors = onUnauthorized => {\n  // Request interceptor: Agregar token a todas las peticiones\n  axios.interceptors.request.use(config => {\n    const token = TokenManager.getAccessToken();\n    if (token && config.url !== AUTH_ENDPOINTS.REFRESH) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  }, error => {\n    return Promise.reject(error);\n  });\n\n  // Response interceptor: Manejar errores de autenticación\n  axios.interceptors.response.use(response => response, async error => {\n    var _error$response;\n    const originalRequest = error.config;\n\n    // Si el error es 401 y no es una retry\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      // Intentar refrescar el token\n      const refreshToken = TokenManager.getRefreshToken();\n      if (refreshToken) {\n        try {\n          const response = await axios.post(AUTH_ENDPOINTS.REFRESH, {\n            refreshToken\n          });\n          const {\n            accessToken\n          } = response.data;\n          TokenManager.setAccessToken(accessToken);\n\n          // Reintentar la petición original con el nuevo token\n          originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n          return axios(originalRequest);\n        } catch (refreshError) {\n          // Si falla el refresh, cerrar sesión\n          TokenManager.clearAll();\n          if (onUnauthorized) {\n            onUnauthorized();\n          }\n          return Promise.reject(refreshError);\n        }\n      } else {\n        // No hay refresh token, cerrar sesión\n        TokenManager.clearAll();\n        if (onUnauthorized) {\n          onUnauthorized();\n        }\n      }\n    }\n    return Promise.reject(error);\n  });\n};\n\n/**\n * Iniciar sesión\n */\nexport const login = async (email, password, rememberMe = false) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.LOGIN, {\n      email,\n      password,\n      rememberMe\n    });\n    const {\n      user,\n      tokens\n    } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n    if (tokens.rememberToken) {\n      TokenManager.setRememberToken(tokens.rememberToken);\n    }\n    TokenManager.setUser(user);\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Registrar nuevo usuario\n */\nexport const register = async (email, password, businessName, rememberMe = false) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.REGISTER, {\n      email,\n      password,\n      businessName,\n      rememberMe\n    });\n    const {\n      user,\n      tokens\n    } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n    if (tokens.rememberToken) {\n      TokenManager.setRememberToken(tokens.rememberToken);\n    }\n    TokenManager.setUser(user);\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Cerrar sesión\n */\nexport const logout = async () => {\n  try {\n    const token = TokenManager.getAccessToken();\n    if (token) {\n      await axios.post(AUTH_ENDPOINTS.LOGOUT);\n    }\n  } catch (error) {\n    console.error('Error en logout:', error);\n  } finally {\n    // Siempre limpiar el localStorage\n    TokenManager.clearAll();\n  }\n};\n\n/**\n * Refrescar access token\n */\nexport const refreshAccessToken = async () => {\n  try {\n    const refreshToken = TokenManager.getRefreshToken();\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n    const response = await axios.post(AUTH_ENDPOINTS.REFRESH, {\n      refreshToken\n    });\n    const {\n      accessToken\n    } = response.data;\n    TokenManager.setAccessToken(accessToken);\n    return accessToken;\n  } catch (error) {\n    TokenManager.clearAll();\n    throw error;\n  }\n};\n\n/**\n * Login con remember token (sesión persistente)\n */\nexport const loginWithRemember = async rememberToken => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.LOGIN_WITH_REMEMBER, {\n      rememberToken\n    });\n    const {\n      user,\n      tokens\n    } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n    TokenManager.setRememberToken(tokens.rememberToken);\n    TokenManager.setUser(user);\n    return response.data;\n  } catch (error) {\n    // Si falla, limpiar remember token inválido\n    TokenManager.setRememberToken(null);\n    throw error;\n  }\n};\n\n/**\n * Obtener usuario actual\n */\nexport const getCurrentUser = async () => {\n  try {\n    // Primero intentar desde localStorage\n    const cachedUser = TokenManager.getUser();\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    // Si no hay caché, hacer petición al servidor\n    const response = await axios.get(AUTH_ENDPOINTS.ME);\n    const {\n      user\n    } = response.data;\n    TokenManager.setUser(user);\n    return user;\n  } catch (error) {\n    throw error;\n  }\n};\nexport const updateProfile = async updates => {\n  try {\n    const response = await axios.put(AUTH_ENDPOINTS.UPDATE_PROFILE, updates);\n    const {\n      user\n    } = response.data;\n    TokenManager.setUser(user);\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};","map":{"version":3,"names":["forgotPassword","email","response","axios","post","AUTH_ENDPOINTS","FORGOT_PASSWORD","data","error","resetPassword","token","newPassword","RESET_PASSWORD","isAuthenticated","TokenManager","hasValidSession","getUserFromStorage","getUser","API_URL","process","env","REACT_APP_API_URL","LOGIN","REGISTER","LOGOUT","REFRESH","ME","UPDATE_PROFILE","LOGIN_WITH_REMEMBER","getAccessToken","localStorage","getItem","setAccessToken","setItem","removeItem","getRefreshToken","setRefreshToken","getRememberToken","setRememberToken","userStr","JSON","parse","setUser","user","stringify","clearAll","setupAxiosInterceptors","onUnauthorized","interceptors","request","use","config","url","headers","Authorization","Promise","reject","_error$response","originalRequest","status","_retry","refreshToken","accessToken","refreshError","login","password","rememberMe","tokens","rememberToken","register","businessName","logout","console","refreshAccessToken","Error","loginWithRemember","getCurrentUser","cachedUser","get","updateProfile","updates","put"],"sources":["/home/fred/adminia-frontend/src/services/auth.js"],"sourcesContent":["/**\n * Solicitar reset de contraseña\n */\nexport const forgotPassword = async (email) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.FORGOT_PASSWORD, { email });\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Resetear contraseña con token\n */\nexport const resetPassword = async (token, newPassword) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.RESET_PASSWORD, {\n      token,\n      newPassword\n    });\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Verificar si el usuario está autenticado\n */\nexport const isAuthenticated = () => {\n  return TokenManager.hasValidSession();\n};\n\n/**\n * Obtener información del usuario desde localStorage\n */\nexport const getUserFromStorage = () => {\n  return TokenManager.getUser();\n};\n\n/**\n * ============================================\n * SERVICIO DE AUTENTICACIÓN - Frontend\n * ============================================\n * Archivo: services/auth.js\n * Propósito: Manejo de autenticación y tokens en el cliente\n * \n * Funciones principales:\n * - login: Iniciar sesión\n * - register: Registrar nuevo usuario\n * - logout: Cerrar sesión\n * - refreshToken, rememberToken, user\n */\n\nimport axios from 'axios';\n\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n\nconst AUTH_ENDPOINTS = {\n  LOGIN: `${API_URL}/auth/login`,\n  REGISTER: `${API_URL}/auth/register`,\n  LOGOUT: `${API_URL}/auth/logout`,\n  REFRESH: `${API_URL}/auth/refresh`,\n  ME: `${API_URL}/auth/me`,\n  UPDATE_PROFILE: `${API_URL}/auth/update-profile`,\n  FORGOT_PASSWORD: `${API_URL}/auth/forgot-password`,\n  RESET_PASSWORD: `${API_URL}/auth/reset-password`,\n  LOGIN_WITH_REMEMBER: `${API_URL}/auth/login-with-remember`\n};\n\n/**\n * Gestión de tokens en localStorage\n */\nexport const TokenManager = {\n  getAccessToken: () => localStorage.getItem('accessToken'),\n\n  setAccessToken: (token) => {\n    if (token) {\n      localStorage.setItem('accessToken', token);\n    } else {\n      localStorage.removeItem('accessToken');\n    }\n  },\n\n  getRefreshToken: () => localStorage.getItem('refreshToken'),\n\n  setRefreshToken: (token) => {\n    if (token) {\n      localStorage.setItem('refreshToken', token);\n    } else {\n      localStorage.removeItem('refreshToken');\n    }\n  },\n\n  getRememberToken: () => localStorage.getItem('rememberToken'),\n\n  setRememberToken: (token) => {\n    if (token) {\n      localStorage.setItem('rememberToken', token);\n    } else {\n      localStorage.removeItem('rememberToken');\n    }\n  },\n\n  getUser: () => {\n    const userStr = localStorage.getItem('user');\n    return userStr ? JSON.parse(userStr) : null;\n  },\n\n  setUser: (user) => {\n    if (user) {\n      localStorage.setItem('user', JSON.stringify(user));\n    } else {\n      localStorage.removeItem('user');\n    }\n  },\n\n  clearAll: () => {\n    localStorage.removeItem('accessToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('rememberToken');\n    localStorage.removeItem('user');\n  },\n\n  hasValidSession: () => {\n    return !!TokenManager.getAccessToken() || !!TokenManager.getRememberToken();\n  }\n};\n\n/**\n * Configurar interceptor de axios para incluir token automáticamente\n */\nexport const setupAxiosInterceptors = (onUnauthorized) => {\n  // Request interceptor: Agregar token a todas las peticiones\n  axios.interceptors.request.use(\n    (config) => {\n      const token = TokenManager.getAccessToken();\n      if (token && config.url !== AUTH_ENDPOINTS.REFRESH) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    },\n    (error) => {\n      return Promise.reject(error);\n    }\n  );\n\n  // Response interceptor: Manejar errores de autenticación\n  axios.interceptors.response.use(\n    (response) => response,\n    async (error) => {\n      const originalRequest = error.config;\n\n      // Si el error es 401 y no es una retry\n      if (error.response?.status === 401 && !originalRequest._retry) {\n        originalRequest._retry = true;\n\n        // Intentar refrescar el token\n        const refreshToken = TokenManager.getRefreshToken();\n\n        if (refreshToken) {\n          try {\n            const response = await axios.post(AUTH_ENDPOINTS.REFRESH, { refreshToken });\n            const { accessToken } = response.data;\n\n            TokenManager.setAccessToken(accessToken);\n\n            // Reintentar la petición original con el nuevo token\n            originalRequest.headers.Authorization = `Bearer ${accessToken}`;\n            return axios(originalRequest);\n          } catch (refreshError) {\n            // Si falla el refresh, cerrar sesión\n            TokenManager.clearAll();\n            if (onUnauthorized) {\n              onUnauthorized();\n            }\n            return Promise.reject(refreshError);\n          }\n        } else {\n          // No hay refresh token, cerrar sesión\n          TokenManager.clearAll();\n          if (onUnauthorized) {\n            onUnauthorized();\n          }\n        }\n      }\n\n      return Promise.reject(error);\n    }\n  );\n};\n\n/**\n * Iniciar sesión\n */\nexport const login = async (email, password, rememberMe = false) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.LOGIN, {\n      email,\n      password,\n      rememberMe\n    });\n\n    const { user, tokens } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n\n    if (tokens.rememberToken) {\n      TokenManager.setRememberToken(tokens.rememberToken);\n    }\n\n    TokenManager.setUser(user);\n\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Registrar nuevo usuario\n */\nexport const register = async (email, password, businessName, rememberMe = false) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.REGISTER, {\n      email,\n      password,\n      businessName,\n      rememberMe\n    });\n\n    const { user, tokens } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n\n    if (tokens.rememberToken) {\n      TokenManager.setRememberToken(tokens.rememberToken);\n    }\n\n    TokenManager.setUser(user);\n\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * Cerrar sesión\n */\nexport const logout = async () => {\n  try {\n    const token = TokenManager.getAccessToken();\n\n    if (token) {\n      await axios.post(AUTH_ENDPOINTS.LOGOUT);\n    }\n  } catch (error) {\n    console.error('Error en logout:', error);\n  } finally {\n    // Siempre limpiar el localStorage\n    TokenManager.clearAll();\n  }\n};\n\n/**\n * Refrescar access token\n */\nexport const refreshAccessToken = async () => {\n  try {\n    const refreshToken = TokenManager.getRefreshToken();\n\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    const response = await axios.post(AUTH_ENDPOINTS.REFRESH, { refreshToken });\n    const { accessToken } = response.data;\n\n    TokenManager.setAccessToken(accessToken);\n\n    return accessToken;\n  } catch (error) {\n    TokenManager.clearAll();\n    throw error;\n  }\n};\n\n/**\n * Login con remember token (sesión persistente)\n */\nexport const loginWithRemember = async (rememberToken) => {\n  try {\n    const response = await axios.post(AUTH_ENDPOINTS.LOGIN_WITH_REMEMBER, {\n      rememberToken\n    });\n\n    const { user, tokens } = response.data;\n\n    // Guardar tokens y usuario\n    TokenManager.setAccessToken(tokens.accessToken);\n    TokenManager.setRefreshToken(tokens.refreshToken);\n    TokenManager.setRememberToken(tokens.rememberToken);\n    TokenManager.setUser(user);\n\n    return response.data;\n  } catch (error) {\n    // Si falla, limpiar remember token inválido\n    TokenManager.setRememberToken(null);\n    throw error;\n  }\n};\n\n/**\n * Obtener usuario actual\n */\nexport const getCurrentUser = async () => {\n  try {\n    // Primero intentar desde localStorage\n    const cachedUser = TokenManager.getUser();\n\n    if (cachedUser) {\n      return cachedUser;\n    }\n\n    // Si no hay caché, hacer petición al servidor\n    const response = await axios.get(AUTH_ENDPOINTS.ME);\n    const { user } = response.data;\n\n    TokenManager.setUser(user);\n\n    return user;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const updateProfile = async (updates) => {\n  try {\n    const response = await axios.put(AUTH_ENDPOINTS.UPDATE_PROFILE, updates);\n    const { user } = response.data;\n\n    TokenManager.setUser(user);\n\n    return response.data;\n  } catch (error) {\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}